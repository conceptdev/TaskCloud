{"Name":"Dropbox Sync \u0026 Datastore","Id":912,"Alias":"dropboxsync","Description":"The Dropbox Sync API allows you to give your app its own private Dropbox client and leave the syncing to Dropbox.\n\n- Focus on your data. The Sync API handles all the caching, retrying, and file change notifications.\n- Writes are local so changes are immediate. The Sync API syncs to Dropbox behind the scenes.\n- Your app works great even when offline and automatically syncs when it\u0027s back online.\n\n### Datastore API\n\nKeep your app\u0027s structured data in sync with Dropbox. These days, your app need to store and sync more than just files. With the Datastore API, structured data like contacts, to-do items, and game state can be synced effortlessly. Datastores work across platforms, offline, and even support automatic conflict resolution.\n\n## Authenticating with Dropbox\n\nAdd the following lines of code to link a user\u0027s Dropbox account to your\napp:\n\n### In AppDelegate.cs\n\n```csharp\nusing DropBoxSync.iOS;\n...\n\n// Get your own App Key and Secret from https://www.dropbox.com/developers/apps\nconst string DropboxSyncKey = \"YOUR_APP_KEY\";\nconst string DropboxSyncSecret = \"YOUR_APP_SECRET\";\n\npublic override bool FinishedLaunching (UIApplication app, NSDictionary options)\n{\n\t\n\t// The account manager stores all the account info. Create this when your app launches\n\tvar manager = new DBAccountManager (DropboxSyncKey, DropboxSyncSecret);\n\tDBAccountManager.SharedManager = manager;\n\n\tvar account = manager.LinkedAccount;\n\tif (account != null) {\n\t\tvar filesystem = new DBFilesystem (account);\n\t\tDBFilesystem.SharedFilesystem = filesystem;\n\t}\t\n\n\t// ...\n}\n\npublic override bool OpenUrl (UIApplication application, NSUrl url, string sourceApplication, NSObject annotation)\n{\n\tvar account = DBAccountManager.SharedManager.HandleOpenURL (url);\n\tif (account != null) {\n\t\tvar filesystem = new DBFilesystem (account);\n\t\tDBFilesystem.SharedFilesystem = filesystem;\n\t\tConsole.WriteLine (\"App linked successfully!\");\n\t\treturn true;\n\t} else {\n\t\tConsole.WriteLine (\"App is not linked\");\n\t\treturn false;\n\t}\n}\n\n```\n\n### In Info.plist\n\nYou\u0027ll need to register the url scheme \"db-DropboxSyncKey\" to complete the\nauthentication flow. Double-click on your app\u0027s Info.plist file, select\nthe Advanced Tab, find the URL Types Section, then click Add URL Type\nand set URL Schemes to db-DropboxSyncKey (i.e.\t\"db-aaa111bbb2222\").\n\n### Link the user\n\nOnce you\u0027ve added the code above, you\u0027re ready to link the user\u0027s\nDropbox account from your UI. For example, add this snippet to a UI\nevent handler in one of your controllers:\n\n```csharp\nDBAccountManager.SharedManager.LinkFromController (myController)\n```\n\nThis will show the Dropbox OAuth screen and ask the user to link their\naccount.\n","Version":"3.0.2","Summary":"Give your app its own private Dropbox client and leave the syncing to Dropbox.","QuickStart":"## Troubleshooting on Android\nBefore you start using this component, do the following steps on your project to avoid app crashes:\n\nOpen your AndroidManifest.xml and change the following line from:\n \n```xml\n\u003capplication android:label=“YourAwesomeAppName\"\u003e\n```\n\nto:\n\n```xml\n\u003capplication android:label=\"@string/app_name\"\u003e\n```\n\nAnd make sure you have the following line in your Resources/values/Strings.xml\n\n```xml\n\u003cstring name=\"app_name”\u003eYourAwesomeAppName\u003c/string\u003e\n```\n\n## In AndroidManifest.xml\n\nRequired permissions (inside the \u003cmanifest\u003e element).\n\n```xml\n\u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e\n\u003cuses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /\u003e\n```\n\nActivities and Services (inside the \u003capplication\u003e element).\nBe sure to replace the APP_KEY below with your real Dropbox app key, which can be found in the App Console.\n\n```xml\n\u003cactivity android:name=\"com.dropbox.sync.android.DbxAuthActivity\" /\u003e\n\u003cactivity\n  android:name=\"com.dropbox.client2.android.AuthActivity\"\n  android:launchMode=\"singleTask\" \u003e\n  \u003cintent-filter\u003e\n    \u003cdata android:scheme=\"db-APP_KEY\" /\u003e\n    \u003caction android:name=\"android.intent.action.VIEW\" /\u003e\n    \u003ccategory android:name=\"android.intent.category.BROWSABLE\" /\u003e\n    \u003ccategory android:name=\"android.intent.category.DEFAULT\" /\u003e\n  \u003c/intent-filter\u003e\n\u003c/activity\u003e\n\u003cservice\n  android:name=\"com.dropbox.sync.android.DbxSyncService\"\n  android:enabled=\"true\"\n  android:exported=\"false\"\n  android:label=\"Dropbox Sync\" /\u003e\n```\n\n## Authentication with Dropbox on Android\n\nCreate a DBAccountManager object. This object lets you link to a Dropbox user\u0027s account which is the first step to working with data on their behalf. A good place to do so is in your onCreate() method:\n\n```csharp\nconst string DropboxSyncKey = \"YOUR_APP_KEY\";\nconst string DropboxSyncSecret = \"YOUR_APP_SECRET\";\nDBAccountManager Account { get; set; }\n\nprotected override void OnCreate (Bundle bundle)\n{\n\tbase.OnCreate (bundle);\n\tAccount = DBAccountManager.GetInstance (ApplicationContext, DropboxSyncKey, DropboxSyncSecret);\n}\t\n```\n\n## Link the user\n\nStarting the linking process will launch an external Activity so your app will need to override onActivityResult() which will be called when linking is complete. You need to specify a request code, you can specify any request code you want, it\u0027s just used to indicate the reason that onActivityResult() is being called:\n\n```csharp\nconst int LinkToDropboxRequest = 0; // This value is up to you\n\npublic void SomeMethod ()\n{\n\tAccount.StartLink (this, LinkToDropboxRequest);\n} \n\nprotected override void OnActivityResult (int requestCode, Result resultCode, Intent data)\n{\n\tif (code == LinkToDropboxRequest \u0026\u0026 resultCode != Result.Canceled) {\n\t\t// Your account is linked! Start using Dropbox files!\n\t} else {\n\t\t// Link failed or was cancelled by the user...\n\t}\n}\n```\n\n## Working with files\n\n```csharp\npublic void CreateFile ()\n{\n\tfileSystem = DBFileSystem.ForAccount (Account.LinkedAccount);\n\t\n\tDBFile testFile = fileSystem.Create(new DBPath(\"hello.txt\"));\n\ttry {\n\t    testFile.WriteString(\"Hello Dropbox!\");\n\t} finally {\n\t    testFile.Close();\n\t}\n}\n```\n\nWriting to the file will succeed even if you are offline, and automatically sync to the server once your app comes back online.\n\nReading a file is just as easy:\n\n```csharp\nDBFile testFile = fileSystem.Open (testPath);\ntry {\n\tString contents = testFile.ReadString ();\n\tConsole.WriteLine (\"Dropbox Test\", \"File contents: \" + contents);\n} finally {\n\ttestFile.Close ();\n}\n```\n\nIf the file isn\u0027t cached yet, ReadString() will wait while the file downloads.\n\n### Listening for changes\n\nYou can check whether the file isCached and can be read immediately by using the **DBFile.SyncStatus** property. If it\u0027s not cached, the **ReadString ()** call will wait while it downloads. If you don\u0027t want to wait, you can override the **DBFile.FileChange** event:\n\n```csharp\ntestFile.FileChanged += (sender, e) =\u003e {\n\t// Check testFile.getSyncStatus() and read if it\u0027s ready\n};\n```\n\n## Creating a datastore and your first table\n\nWith a DBAccount in hand, the next step is to open the default datastore. Each app has its own default datastore per user.\n\n```csharp\nDBDatastore store = DBDatastore.OpenDefault(Account.LinkedAccount);\n```\n\nIn order to store records in a datastore, you\u0027ll need to put them in a table. Let\u0027s define a table named \"tasks\":\n\n```csharp\nDBTable tasks = store.GetTable(\"tasks\");\n```\n\n### Working with records\n\nA record is a set of name and value pairs called fields, similar in concept to a map. Records in the same table can have different combinations of fields; there\u0027s no schema on the table which contains them. You can insert the record and add fields to it in a single line of code:\n\n```csharp\nDBRecord firstTask = tasks.Insert().Set(\"taskname\", \"Buy milk\").Set(\"completed\", false);\n```\n\nThis task is now in memory, but hasn\u0027t been persisted to storage or synced to Dropbox. Thankfully, that\u0027s simple:\n\n```csharp\nstore.Sync();\n```\n\nSync both saves all of your local changes and applies any remote changes as well, automatically merging and dealing with conflicts along the way. Sync even works offline; you won\u0027t apply any remote changes, but your local changes will be saved to persistent storage and synced to Dropbox when the device comes back online.\n\n### Accessing data\n\n```csharp\nString taskname = firstTask.GetString(\"taskname\");\n```\n\n### Editing tasks\n\n```csharp\nfirstTask.Set(\"completed\", true);\nstore.Sync();\n```\n\n### Deleting the record\n\n```csharp\nfirstTask.DeleteRecord();\nstore.Dync();\n```\n\n## Querying records\n\nYou can query the records in a table to get a subset of records that match a set of field names and values you specify. The query method takes a set of conditions that the fields of a record must match to be returned in the result set. For each included condition, all records must have a field with that name and that field\u0027s value must be exactly equal to the specified value. For strings, this is a case-sensitive comparison (e.g. \"abc\" won\u0027t match \"ABC\").\n\n```csharp\nDBFields queryParams = new DBFields ().Set (\"completed\", false);\nDBTable.QueryResult results = tasks.Query (queryParams);\nDBRecord firstResult = results.ToEnumerable\u003cDBRecord\u003e ().FirstOrDefault ();\n```\n\nResults provides an iterable set of DBRecord objects.\n\nThe records that meet the specified query are not returned in any guaranteed order. The entire result set is returned so you may apply sort in memory after the request completes.\n\nIf no condition set is provided, the query will return every record in the table.\n\nDBTable.QueryResult results = tasks.query();\n\n## Using events for listening\n\nA datastore will receive changes from other instances of your app when you call sync(). For some apps, the frequency of updates will be low; others may be rapid-fire. In either case, your app should respond as soon as those changes happen by updating the state of your app.\n\n```csharp\nstore.DatastoreChanged += (sender, e) =\u003e {\n\tif (e.P0.SyncStatus.HasIncoming) {\n\t\ttry {\n\t\t\tvar change = store.Sync ();\n\t\t\t// Handle changes\n\t\t} catch (Exception ex) {\n\t\t\t// Handle Exception\n\t\t}\n\t}\n};\n```\n\nThe **DBDatastore.DatastoreChanged** method is called whenever the state of the datastore changes, which includes downloading or uploading changes. It is also called when there are changes ready to be applied to the local state.\n\nChecking SyncStatus.HasIncoming in the event lets you figure out when there are new changes that your app should respond to. If there are changes, calling **Sync ()** will apply those changes to the datastore. **Sync ()** will also return a mapping of tables to sets of records that changed as a result of the sync. Your app can update based on the set of changed records, or you can simply query the new states of the tables and update your app\u0027s views with the results.\n\n## Authenticating with Dropbox on iOS\n\nAdd the following lines of code to link a user\u0027s Dropbox account to your\napp:\n\n### In AppDelegate.cs\n\n```csharp\nusing DropBoxSync.iOS;\n...\n\n// Get your own App Key and Secret from https://www.dropbox.com/developers/apps\nconst string DropboxSyncKey = \"YOUR_APP_KEY\";\nconst string DropboxSyncSecret = \"YOUR_APP_SECRET\";\n\npublic override bool FinishedLaunching (UIApplication app, NSDictionary options)\n{\n\t\n\t// The account manager stores all the account info. Create this when your app launches\n\tvar manager = new DBAccountManager (DropboxSyncKey, DropboxSyncSecret);\n\tDBAccountManager.SharedManager = manager;\n\n\tvar account = manager.LinkedAccount;\n\tif (account != null) {\n\t\tvar filesystem = new DBFilesystem (account);\n\t\tDBFilesystem.SharedFilesystem = filesystem;\n\t}\t\n\n\t// ...\n}\n\npublic override bool OpenUrl (UIApplication application, NSUrl url, string sourceApplication, NSObject annotation)\n{\n\tvar account = DBAccountManager.SharedManager.HandleOpenURL (url);\n\tif (account != null) {\n\t\tvar filesystem = new DBFilesystem (account);\n\t\tDBFilesystem.SharedFilesystem = filesystem;\n\t\tConsole.WriteLine (\"App linked successfully!\");\n\t\treturn true;\n\t} else {\n\t\tConsole.WriteLine (\"App is not linked\");\n\t\treturn false;\n\t}\n}\n\n```\n\n### In Info.plist\n\nYou\u0027ll need to register the url scheme \"db-APP_KEY\" to complete the\nauthentication flow. Double-click on your app\u0027s Info.plist file, select\nthe Advanced Tab, find the URL Types Section, then click Add URL Type\nand set URL Schemes to db-APP_KEY (i.e.\t\"db-aaa111bbb2222\").\n\n### Link the user\n\nOnce you\u0027ve added the code above, you\u0027re ready to link the user\u0027s\nDropbox account from your UI. For example, add this snippet to a UI\nevent handler in one of your controllers:\n\n```csharp\nDBAccountManager.SharedManager.LinkFromController (myController)\n```\n\nThis will show the Dropbox OAuth screen and ask the user to link their\naccount.\n\n## Listing folders\n\nOnce you\u0027ve linked your app to a Dropbox account, you may want to list\nthe contents of your app\u0027s exclusive Dropbox folder. If you used the\nsample code above, once you\u0027re authenticated you should have a properly\nauthorized `DBFilesystem` instance stored in\n`DBFilesystem.SharedFilesystem`, which is the object that allows you to\nlist folders; and open, move or delete files.\n\n```csharp\nvoid ListFiles (string path)\n{\n\tDBError error;\n\n\tvar contents = DBFilesystem.SharedFilesystem.ListFolder (path, out error);\n\tforeach (DBFileInfo info in contents) {\n\t\tConsole.WriteLine (info.Path);\n\t}\t\n}\n```\n\nSync API method calls involving file reads are synchronous, meaning they wait until the\nrequested data is available, or until an error occurs and an exception\nis thrown. You should make sure all DBFilesystem and DBFile calls are\ndone from a background thread to keep your UI responsive.\n\n## Working with files\n\nInitially, your app\u0027s folder in your user\u0027s Dropbox won\u0027t contain any\nfiles, so you\u0027ll need to create one:\n\n```csharp\nvoid CreateFile ()\n{\n\tDBError error;\n\n\tvar dbpath = DBPath.Root.ChildPath (\"hello.txt\");\n\tvar file = DBFilesystem.SharedFilesystem.CreateFile (dbpath, out error);\n\tfile.WriteString (\"Hello World!\", out error);\n}\n```\n\nWriting to the file will succeed immediately, and the Sync API will sync\nthe file to Dropbox asynchronously. Even if you are offline, the write\nwill succeed and it will be automatically synced to the server once your\napp comes back online.\n\nReading a file is just as easy: you can call `DBFile.ReadString` to get\na file\u0027s contents as a UTF8 string. If the file is not cached, this\noperation can take a while, so always call this method on a background\nthread.\n\n## Watching for changes\n\nMany objects in the Sync API allow you to register a callback\nthat will get called when something about a file changes. Here\u0027s an\nexample of how to find out when a file has changed:\n\n```csharp\nvoid CreateAndWatchFile ()\n{\n\t// First, create a file to change for demo purposes.\n\tDBError err; \n\tDBPath path = DBPath.Root.ChildPath (\"change-me.txt\");\n\tDBFile file = DBFilesystem.SharedFilesystem.CreateFile (path, out err);\n\n\t// Next, register for changes on that file.\n\tfile.AddObserver (this, () =\u003e {\n\t\t\tDBFileStatus status = file.NewerStatus;\n\n\t\t\t// If file.NewerStatus is null, the file hasn\u0027t changed.\n\t\t\tif (status == null) return;\n\n\t\t\tif (status.Cached) {\n\t\t\t\tDBError error;\n\t\t\t\tfile.Update (out error);\n\t\t\t\tConsole.WriteLine (\"The updated file has finished downloading\");\n\t\t\t} else {\n\t\t\t\tConsole.WriteLine (\"The file is still downloading\");\n\t\t\t}\n\t});\n}\n```\n\nIn the example above, every time you edit \"change-me.txt\" in your app\u0027s\nDropbox folder, the callback will print to the console when the file\nstarts downloading,\nand print again when it finishes downloading.\n\nTo stop listening for updates:\n\n```csharp\nfile.RemoveObserver (this);\n```\n\n## Creating a datastore and your first table\n\nWith a DBAccount in hand, the next step is to open the default datastore. Each app has its own default datastore per user.\n\n```csharp\nDBDatastore store = DBDatastore.OpenDefaultStoreForAccount (account, out error);\n```\n\nIn order to store records in a datastore, you\u0027ll need to put them in a table. Let\u0027s define a table named \"people\":\n\n```csharp\nDBTable tasksTbl = store.GetTable (\"people\");\n```\n\nYou\u0027ve got a datastore manager, a datastore for your app, and a table for all the tasks you\u0027re about to make. Let\u0027s start storing some data.\n\n## Working with records\n\nA record is a set of name and value pairs called fields, similar in concept to a dictionary. Records in the same table can have different combinations of fields; there\u0027s no schema on the table which contains them. In fact, the record is created by first creating a dictionary.\n\n```csharp\nvar keys = new NSString[] {\n\tnew NSString(\"taskname\"),\n\tnew NSString(\"completed\")\n};\nvar values = new NSString[] {\n\tnew NSString(\"Buy milk\"),\n\tnew NSString(\"No\")\n};\n\nNSDictionary data = NSDictionary.FromObjectsAndKeys (values, keys);\n\nDBRecord firstTask = tasksTbl.Insert (data);\n```\n\nThis task is now in memory, but hasn\u0027t been persisted to storage or synced to Dropbox. Thankfully, that\u0027s simple:\n\n```csharp\nstore.Sync (null);\n```\n\nSync may be a straightforward method, but it wraps some powerful functionality. Sync both saves all of your local changes and applies any remote changes as well, automatically merging and dealing with conflicts along the way. Sync even works offline; you won\u0027t apply any remote changes, but your local changes will be saved to persistent storage and synced to Dropbox when the device comes back online.\n\nOnce syncing completes, visit the [datastore web inspector](https://www.dropbox.com/developers/apps/datastores) and you should see your newly created task.\n\nAccessing data from a record is straightforward:\n\n```csharp\nstring taskname = (NSString) firstTask [\"taskname\"];\n```\n\nEditing tasks is just as easy. This is how you can mark the first result as completed:\n\n```csharp\nfirstTask[\"completed\"] = \"Yes\";\nstore.Sync (null);\n```\n\nAfter the edit, calling sync will commit the edits locally and then sync them to Dropbox.\n\nFinally, if you want to remove the record completely, just call DeleteRecord ():\n\n```csharp\nfirstTask.DeleteRecord ();\nstore.Sync (null);\n```\n\n## Querying records\n\nYou can query the records in a table to get a subset of records that match a set of field names and values you specify. The query method takes a set of conditions that the fields of a record must match to be returned in the result set. For each included condition, all records must have a field with that name and that field\u0027s value must be exactly equal to the specified value. For strings, this is a case-sensitive comparison (e.g. \"abc\" won\u0027t match \"ABC\").\n\n```csharp\nDBRecord [] results = tasksTbl.Query (NSDictionary.FromObjectAndKey (new NSString (\"No\"), new NSString (\"completed\")), error);\nDBRecord firstResult = results [0];\n```\n\nThe records that meet the specified query are not returned in any guaranteed order. The entire result set is returned so you may apply sort in memory after the request completes.\n\nIf no condition set is provided, the query will return every record in the table.\n\n```csharp\nDBRecord [] results = tasksTbl.Query (null, error);\n```\n\n## Using observers\n\nA datastore will receive changes from other instances of your app when you call sync. For some apps, the frequency of updates will be low; others may be rapid-fire. In either case, your app should respond as soon as those changes happen by updating the state of your app. You can do this by registering sync status observers.\n\n```csharp\nstore.AddObserver (store, () =\u003e {\n\tif (store.Status == DBDatastoreStatus.Incoming) {\n\t\t// Handle the updated data\n\t}\n});\n```\n\nThe observer\u0027s handler is called whenever the status of the datastore changes, which includes downloading or uploading changes. It is also called when there are changes ready to be applied to the local state.\n\nChecking store.Status in the handler lets you figure out when there are new changes that your app should respond to. If there are changes, calling sync will apply those changes to the datastore. sync will also return a dictionary of table IDs to sets of records that changed as a result of the sync. Your app can update based on the set of changed records or you can simply query the new states of the tables and update your app\u0027s views with the results.\n\n## Records and fields\n\nThe record is the smallest grouping of data in a datastore. It combines a set of fields to make a useful set of information within a table.\n\n## Record IDs\n\nEach record has a string ID. An ID can be provided when a record is created, or one will be automatically generated and assigned if none is provided. Once a record is created, the ID cannot be changed.\n\nOther records can refer to a given record by storing its ID. This is similar to the concept of a foreign key in SQL databases.\n\n## Field types\n\nRecords can contain a variety of field types. Earlier in this tutorial, you saw strings and booleans, but you can also specify a number of other types. Here is a complete list of all supported types:\n\n- String\n- Boolean\n- Integer – 64 bits, signed\n- Floating point – IEEE double\n- Date – POSIX-like timestamp stored with millisecond precision.\n- Bytes – Arbitrary data, which is treated as binary, such as thumbnail images and compressed data. Individual records can be up to 100KB, which limits the size of the blob. If you want to store larger files, you should use the Sync API and reference the paths to those files in your records. If you want to store larger files, you should use the Sync API and reference the paths to those files in your records.\n- List – A special value that can contain other values, though not other lists. Lists are described in more detail below.\n\n## Lists and List Operations\n\nLists are special field values. They contain an ordered list of other values, though not other lists. Lists can be manipulated via four list operations: put (i.e. replace), move, insert, and delete. These list operations allow Dropbox to handle merging changes to the structure of the list automatically.\n\n## Storage size limits\n\nThe overall size of a datastore is calculated by summing the sizes of all values of all fields. Your app can store up to 5MB of data across all its datastores without counting against the user\u0027s storage quota. Any data beyond the first 5MB is factored into the user\u0027s Dropbox storage quota, and writing can be limited in these cases when a user is over quota.\n\n## Customizing conflict resolution\n\nDatastores automatically merge changes on a per-field basis. If, for example, a user were to edit the taskname of a task on one device and the completed status of that same task on another device, the Datastore API would merge these changes without a conflict.\n\nSometimes, however, there will be simultaneous changes to the same field of the same record, and this requires conflict resolution. For example, if a user were to edit the completed status of a task on two different devices while offline, it\u0027s unclear how those changes should be merged when the devices come back online. Because of this ambiguity, app developers can choose what conflict resolution rule they want to follow.\n\nTo set the conflict resolution rule, call the SetResolutionRule () method on a table, and pass in the name of a field and the resolution rule you want to apply to that field.\n\n```csharp\ntasksTbl.SetResolutionRule (DBResolutionRule.Local, \"completed\");\n```\n\nThere are five available resolution rules that affect what happens when a remote change conflicts with a local change:\n\n- **DBResolutionRule.Remote** – The remote value will be chosen. This is the default behavior for all fields.\n- **DBResolutionRule.Local** – The local value of the field will be chosen.\n- **DBResolutionRule.Max** – The greater of the two changes will be chosen.\n- **DBResolutionRule.Min** – The lesser of the two changes will be chosen.\n- **DBResolutionRule.Sum** – Additions and subtractions to the value will be preserved and combined.\n\n**Note that resolution rules don\u0027t persist, so you should set any custom resolution rules after opening a datastore but before the first time you sync.**\n\n## Documentation\n\nTo explore the full Dropbox Sync API, check out our [iOS SDK documentation](https://www.dropbox.com/developers/sync/docs/ios).\n","Hash":"52c8a9620e66a542de2aec75bb802fb9","TargetPlatforms":["ios","android"],"TrialHash":null}